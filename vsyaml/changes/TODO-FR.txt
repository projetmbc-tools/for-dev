======
vsyaml - TODO
======


POC dans clalog !


> ---------------------------- <

TOP !!!

    + @-bout s'ppuieera sur vsyaml : une sorte de catalogue de config yaml, que l'on pourra etendre à d'autres situations

    + on gardera le nom historique @-bout même si le catalogue s'éloigne du cadre d'utilisation initial


> ---------------------------- <

on travaille sur des chaînes et non des valeurs modifiés pour sécuriser


> ---------------------------- <

cgf.vs.yaml spéc pour valider un futur cgf.yaml
cgf.vs.hd.yaml : header à la C pour indiquer les valideurs maison disponibles + utilsation de raccorucis


> ---------------------------- <

authors non car list(author) : indiquer de tjrs faire ainsi !


> ---------------------------- <

cle_optionnelle*

cle_astérisque\*                (utile ????)


> ---------------------------- <

valider une clé (majuscule par convenition mais pas obligatoire) : l'opérateur pipe | (penser au pipe de unix et de jinja) indique l'usage d'un cél de noms non fixé à passer à al moulinette

KEY_NAME | mon_valideur:
    ....

KEY_NAME réutilisable ensuite (c'est une var dynamique)


note: \| échapper |           (utile ????)


> ---------------------------- <

les psecs permettent de produire des psecs avec une doc complète om chaque valideur est doc via sa doc utilisateur ou du projet vsyaml !!!


> ---------------------------- <

fournis en plus car assez generaliste

    --> lang en version courte fr, en, ...

    --> path
        path("is_dir") le dir doit exoster
        path("is_file") le fichier  doit exoster

    --> exist(\this.keyname)

        + pour avoir author mais pas authors en même temps via author | not(exist(\this.keyname))

    --> si juste ANY_KIND | in("project", "monorepo") , on ne peut pas utiliser not(exist(...))
        Que faire ?
        ANY_KIND | one_in("project", "monorepo")

        cette cmd empêche que monorepo et project apparaise dans le reste de la spec, TOP !

        par contre si ensuite proect réutilisé, on cumule les specs, ceci factorise les codes avec specs communes

    --> url via regex en interne
    --> std_id et gene_id

        + std_id: noms de var à la python
        + gene_id: std_id pouvant commencer par un chiffre

    --> author

        Validated data.

            + "Name 1, Name 2, Last Name [auth_email_1@provider.abc]"
            + "Name , Last Name [auth_email_1@provider.abc]"
            + "Last Name [auth_email_1@provider.abc]"
            + "Name , Last Name"
            + "Last Name"

        Returned value: a key-val structure with the following signature.

            + Key "names" is for the list of names.
            + Key "last-name" is for the last names.
            + Key "email" is for the email.

    --> institute : "Adress , Name [inst_email_1@inst_provider.abc]"


    --> date qui est un valideur paramétré qui sera tjrs avec val par défaut, pas d'im^plment ici !

        date : par défaut Y-M-D

        date("...") : format maison simple à prendre en main même si plus restreind

            + date("DD/MM/YY") = 'DD/MM/YY'

            + date("D_n D. M_n Y") = 'Day_name DD. Month_name YYYY'

            + D_sn pour short name

            + si beoisn de d ou D, on échappe !


    --> time similaire à date mais pour

    --> map(validator, iterable)

    --> range pour XX .. YY qui extrait XX et YY en verbatim pour usage divers (time date ranges)

        chain(range, map(date, input:keys))


> ---------------------------- <

in déjà utilisé en tant que valideur donc on évite confusion via input même si plus long que in


keys utilisable car input:keys et input.keys sont différents

    --> dangeruex toyt de mêm donc déconseillé !

    --> de même on propose input:vals


chain(timed_seq, auto_refs(input.txt)) car

    + timed_seq renvoie {"time": ..., "txt": ...}
    + auto_refs attend just du texte

ce choix permet de limiter lien entre logique de vs.yaml et implementation : VERBEUX = FACILE

on propose just in pour le moment

    + input.txt pour clé txt du dict in
    + in[0] pour le 1iere elt de la list ou du uplet in


MIEUX !

tout valideur doit renvoyer struct de type dict avec au minimum txt comme clé avec pour valeur un text dont on a extrait ce que l'on voualit et que l'on redonne à la suite de la chapine de valaidation

    + pour une date, on aura une clé "adte" avec une version de la date directement utilisable, idem pour un nbre via "val", et on a tout de meêm accès pour taritement local si justifié

    + dans les cas précédents, on renvoie ce qui a été donnée

    + pour une séquence avec tmps , dans ce cas, plus besoin de renvoyer dans le text le tmps car la valuideur a fait son boulot


> ---------------------------- <

un valideur

    --> si écgec, on lève une xcpetion, tout est stoppé !

    --> sinon, on renvoie une valeur éventuellement utilisable pour une chapine de validation


> ---------------------------- <

Plusieurs validations pout ne pas avoir qu des fonctions dédiées faisant à cahque fois tout, on éclate ainsi les valdiations pour uen utilisation à diféfrents endroits

    --> NEGATION: not(...)

    --> DISJONCTION: any(valid_1 , valid_2, valid_3)

    --> CONJONCTION: all(valid_1 , valid_2, valid_3)

    --> EN SÉRIE:  chain(valid_1 , valid_2, valid_3)

        Ici, valid_1 s'il résussit renvoie une donnée obtenue via la donnée initiale afin de poursuivre une autre validation...

        Par exemple, on peut avoir (cf clalog)

            (1h) Ma séuence chronométré (mon commentaire)

            |
            | validation de 1h stocké côté métier
            |
            v

            Ma séuence chronométré (mon commentaire)

            |
            | valiséuence validée
            |
            v

            STOP !


> ---------------------------- <

in("cor", "done", "out")

    --> list de chaîne uniquement


in(\this.abbrev:keys)

    --> this fait ref au fichier YAML en cours de pséc, donc ici on veut une clée du bloc abbrev du yaml spécifié


in(\./cgf.vs.yaml\.group:keys)

    --> pour clé d'un autre YAML, lui mêem sépcifié, le test d'appratennace se fera bien entendu côté métier

        noter usage de \chemin_relatif\


> ---------------------------- <

list(valid_this)
    --> liste d'objets validé par valid_this
        Côté métier,
        valid_this recoit un item


dict(valid_this | valid_that)
    --> dico de clé validée par valid_this et de valeurs validées par valid_that
        Côté métier,
        valid_this et valid_that recoivent une clé et sa valeur

l_dict(... , ...) = list(dict(... , ...))
    --> une sorte de multi-dicto avec clé répétable


> ---------------------------- <

re("uneReGeX.*")

avec aussi pour paryiculairise suivant le langage qui fera les valdiations

le nom des kangages est en minuscules et doit être pris en compte, donc pour moi ce sera juste lua, l3=latex3 et python à long terme, et voir si d'autres rejoignent l'aventure

implement(
    python: re("uneReGeX-python.*"),
    lua   : re("uneReGeX-lua.*")
)

lang par défaut étant python donc re seul équivaut en interne à implement(python, re("..."))


> ---------------------------- <

le pérécdoe construit prend en charge certains valideurs

    --> str pour string, int...

    --> sin on pris en compte, cela apparaitra clairemnt en commentaire de début de code


> ---------------------------- <

un bloc initial spécial OBLIGATOIRE pour les noms des valideurs afin de répérer des erreurs de saisie;, ou les noms des variables sont juste là pour la sign impércise$

les valideuyrs recoivent un arg et en renvoie un autre, charge au codeur d'utiliser des struct avancés pour multiplier les infos

desc will be dded in autogrenerated code : in Python; we defined a class with metho to be im^lemnted, on surcalsse pour autoriser des me plsu tard; garder cela pour tout les langages pris en compte dans la mesuer du possible


vs.yaml a ses headers dans vs.hd.yaml : plus simple à gérer et poermet de la verbosté dans les desc

myfile.vs.hd.yaml

# création
myvalid_1: >
  \accept: ...

  \return: ...

# réutilistion
myvalid_2: >
  \from: \./path.other.spec/to.reuse.vs.hd.yaml\


pour sequence repétitive, on a un blic spécial, on évitera de manger les valideurs stds tq list ou dict

\abbrev: ????
    nom: code de rempkavement utilisé via \nom


le nom this est réservé !


conseil: \abbrev au début suivi des valideurs rangés par ordre alphabétique



vamideur paramétré même pour "maison"


> ---------------------------- <

TROP VERBAUX donc on vire

\timed_seq: >
  \from: \./day.vs.hd.yaml\

\versatile_date: >
  \from: \./day.vs.hd.yaml\

on founrit le raccorucis


A LA PLACE : une liste d'importation qui a l'aventage de rendre visible les actions d'importation !


\import:
  - \from: \./day.vs.hd.yaml\
    \what:
      - \timed_seq
      - \versatile_date
