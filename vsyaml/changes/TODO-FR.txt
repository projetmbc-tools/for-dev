======
vsyaml - TODO
======


POC dans clalog !


> ---------------------------- <

TOP !!!

    + @-bout s'ppuieera sur vsyaml : une sorte de catalogue de config yaml, que l'on pourra eteindre à d'autres situations

    + on gardera nom historique about même si le catalogue s'loigne du cas d'utilsiation initiale


> ---------------------------- <

on travaille sur des chaînes et non des valeurs modifiés pour sécuriser


> ---------------------------- <

cgf.vs.yaml spéc pour valider un futur cgf.yaml


> ---------------------------- <

cle_optionnelle*

cle_astérisque\*                (utile ????)


> ---------------------------- <

valider une clé (majuscule par convenition mais pas obligatoire) : l'opérateur spécial |> indique l'usage d'un cél de noms non fixé à passer à al moulinette

KEY_NAME |> mon_valideur:
    ....

KEY_NAME réutilisable ensuite (c'est une var dynamique)


note: \|> échapper |>           (utile ????)


> ---------------------------- <

les psecs permettent de produire des psecs avec une doc complète om chaque valideur est doc via sa doc utilisateur ou du projet vsyaml !!!


> ---------------------------- <

fournis en plus car assez generaliste

    --> lang en version courte fr, en, ...

    --> path_dir , path_file

    --> exist(this.keyname)

        + pour avoir author mais pas authors en même temps via author |> not(exist(this.keyname))

    --> si juste ANY_KIND |> in("project", "monorepo") , on ne peut pas utiliser not(exist(...))
        Que faire ?
        ANY_KIND |> one_in("project", "monorepo")

        cette cmd n'empêche que monorepo et project apparaise dans le reste de la spec, TOP !

    --> url via regex en interne
    --> std_id et gene_id

        + std_id: noms de var à la python
        + gene_id: std_id pouvant commencer par un chiffre

    --> author

        Validated data.

            + "Name 1, Name 2, Last Name [auth_email_1@provider.abc]"
            + "Name , Last Name [auth_email_1@provider.abc]"
            + "Last Name [auth_email_1@provider.abc]"
            + "Name , Last Name"
            + "Last Name"

        Returned value: a key-val structure with the following signature.

            + Key "names" is for the list of names.
            + Key "last-name" is for the last names.
            + Key "email" is for the email.

    --> institute : "Adress , Name [inst_email_1@inst_provider.abc]"


    --> date qui est un valideur paramétré qui sera tjrs avec val par défaut, pas d'im^plment ici !

        date : par défaut YYYY-MM-DD

        date("...") : std à al Python https://docs.python.org/fr/3/library/datetime.html#examples-of-usage-date

            + date("%d/%m/%y") = 'DD/MM/YY'

            + date("%A %d. %B %Y") = 'Dayname DD. Montname YYYY'


> ---------------------------- <

chain(timed_seq, auto_refs(in.txt)) car

    + timed_seq renvoie {"time": ..., "txt": ...}
    + auto_refs attend just du texte

ce choix permet de limiter lien entre logique de vs.yaml et implementation : VERBEUX = FACILE

on propose just in pour le moment

    + in.txt pour clé txt du dict in
    + in[0] pour le 1iere elt de la list ou du uplet in


> ---------------------------- <

un valideur

    --> si écgec, on lève une xcpetion, tout est stoppé !

    --> sinon, on renvoie une valeur éventuellement utilisable pour une chapine de validation


> ---------------------------- <

Plusieurs validations pout ne pas avoir qu des fonctions dédiées faisant à cahque fois tout, on éclate ainsi les valdiations pour uen utilisation à diféfrents endroits

    --> NEGATION: not(...)

    --> DISJONCTION: any(valid_1 , valid_2, valid_3)

    --> CONJONCTION: all(valid_1 , valid_2, valid_3)

    --> EN SÉRIE:  chain(valid_1 , valid_2, valid_3)

        Ici, valid_1 s'il résussit renvoie une donnée obtenue via la donnée initiale afin de poursuivre une autre validation...

        Par exemple, on peut avoir (cf clalog)

            (1h) Ma séuence chronométré (mon commentaire)

            |
            | validation de 1h stocké côté métier
            |
            v

            Ma séuence chronométré (mon commentaire)

            |
            | valiséuence validée
            |
            v

            STOP !


> ---------------------------- <

in("cor", "done", "out")

    --> list de chaîne uniquement


in(this.abbrev.key)

    --> this fait ref au fichier YAML en cours de pséc, donc ici on veut une clée du bloc abbrev du yaml spécifié


in(\./cgf.vs.yaml\.group.key)

    --> pour clé d'un autre YAML, lui mêem sépcifié, le test d'appratennace se fera bien entendu côté métier

        noter usage de \chemin_relatif\


> ---------------------------- <

list(valid_this)
    --> liste d'objets validé par valid_this
        Côté métier,
        valid_this recoit un item


dict(valid_this | valid_that)
    --> dico de clé validée par valid_this et de valeurs validées par valid_that
        Côté métier,
        valid_this et valid_that recoivent une clé et sa valeur

l_dict(... , ...) = list(dict(... , ...))
    --> une sorte de multi-dicto avec clé répétable


> ---------------------------- <

re("uneReGeX.*")

avec aussi pour paryiculairise suivant le langage qui fera les valdiations

le nom des kangages est en minuscules et doit être pris en compte, donc pour moi ce sera juste lua, l3=latex3 et python à long terme, et voir si d'autres rejoignent l'aventure

implement(
    python: re("uneReGeX-python.*"),
    lua   : re("uneReGeX-lua.*")
)

lang par défaut étant python donc re seul équivaut en interne à implement(python, re("..."))


> ---------------------------- <

le pérécdoe construit prend en charge certains valideurs

    --> str pour string, int...

    --> sin on pris en compte, cela apparaitra clairemnt en commentaire de début de code


> ---------------------------- <

un bloc initial spécial OBLIGATOIRE pour les noms des valideurs afin de répérer des erreurs de saisie;, ou les noms des variables sont juste là pour la sign impércise$

les valideuyrs recoivent un arg et en renvoie un autre, charge au codeur d'utiliser des struct avancés pour multiplier les infos

desc will be dded in autogrenerated code : in Python; we defined a class with metho to be im^lemnted, on surcalsse pour autoriser des me plsu tard; garder cela pour tout les langages pris en compte dans la mesuer du possible


vs.yaml a ses headers dans vs.hd.yaml : plus simple à gérer et poermet de la verbosté dans les desc

myfile.vs.hd.yaml

# création
myvalid_1: >
  \accept: ...

  \return: ...

# réutilistion
myvalid_2: >
  \from: \./path.other.spec/to.reuse.vs.hd.yaml\


pour sequence repétitive, on a un blic spécial, on évitera de manger les valideurs stds tq list ou dict

\abbrev: ????
    \nom: code de rempkavement



conseil: \abbrev au début suivi des valideurs rangés par ordre alphabétique



vamideur paramétré même pour "maison"


> ---------------------------- <

UTILE ????

    --> \MACROS/:
        on y déf des séquencs de validation trop longue (utile pour les clés)
