======
vsyaml - TODO
======

POC dans clalog !


> ---------------------------- <

on travaille sur des chaînes et non des valeurs modifiés pour sécuriser


> ---------------------------- <

cgf.vs.yaml spéc pour valider un futur cgf.yaml


> ---------------------------- <

cle_optionnelle*

cle_astérisque\*                (utile ????)


> ---------------------------- <

valider une clé (majuscule par convenition mais pas obligatoire) : l'opérateur spécial |> indique l'usage d'un cél de noms non fixé à passer à al moulinette

KEY_NAME |> mon_valideur:
    ....


note: \|> échapper |>           (utile ????)


> ---------------------------- <

les psecs permettent de produire des psecs avec une doc complète om chaque valideur est doc via sa doc utilisateur ou du projet vsyaml !!!


> ---------------------------- <

fournis en plus car assez generaliste

    --> lang en version courte fr, en, ...

    --> path_dir , path_file

    --> XXX

        + pour avoir author mais pas authors en même temps

    --> std_id et gene_id

        + std_id: noms de var à la python
        + gene_id: std_id pouvant commencer par un chiffre

    --> author

        Validated data.

            + "Name 1, Name 2, Last Name [auth_email_1@provider.abc]"
            + "Name , Last Name [auth_email_1@provider.abc]"
            + "Last Name [auth_email_1@provider.abc]"
            + "Name , Last Name"
            + "Last Name"

        Returned value: a key-val structure with the following signature.

            + Key "names" is for the list of names.
            + Key "last-name" is for the last names.
            + Key "email" is for the email.

> ---------------------------- <

un valideur

    --> si écgec, on lève une xcpetion, tout est stoppé !

    --> sinon, on renvoie une valeur éventuellement utilisable pour une chapine de validation


> ---------------------------- <

Plusieurs validations pout ne pas avoir qu des fonctions dédiées faisant à cahque fois tout, on éclate ainsi les valdiations pour uen utilisation à diféfrents endroits

    --> NEGATION: not(...)

    --> DISJONCTION: any(valid_1 , valid_2, valid_3)

    --> CONJONCTION: all(valid_1 , valid_2, valid_3)

    --> EN SÉRIE:  chain(valid_1 , valid_2, valid_3)

        Ici, valid_1 s'il résussit renvoie une donnée obtenue via la donnée initiale afin de poursuivre une autre validation...

        Par exemple, on peut avoir (cf clalog)

            (1h) Ma séuence chronométré (mon commentaire)

            |
            | validation de 1h stocké côté métier
            |
            v

            Ma séuence chronométré (mon commentaire)

            |
            | valiséuence validée
            |
            v

            STOP !


> ---------------------------- <

in("cor", "done", "out")

    --> list de chaîne uniquement


in(this.abbrev.key)

    --> this fait ref au fichier YAML en cours de pséc, donc ici on veut une clée du bloc abbrev du yaml spécifié


in(\./cgf.vs.yaml\.group.key)

    --> pour clé d'un autre YAML, lui mêem sépcifié, le test d'appratennace se fera bien entendu côté métier

        noter usage de \chemin_relatif\


> ---------------------------- <

list(valid_this)
    --> liste d'objets validé par valid_this
        Côté métier,
        valid_this recoit un item


dict(valid_this | valid_that)
    --> dico de clé validée par valid_this et de valeurs validées par valid_that
        Côté métier,
        valid_this et valid_that recoivent une clé et sa valeur

l_dict(... , ...) = list(dict(... , ...))
    --> une sorte de multi-dicto avec clé répétable


> ---------------------------- <

re("uneReGeX.*")

avec aussi pour paryiculairise suivant le langage qui fera les valdiations

le nom des kangages est en minuscules et doit être pris en compte, donc pour moi ce sera juste lua, l3=latex3 et python à long terme, et voir si d'autres rejoignent l'aventure

implement(
    python: re("uneReGeX-python.*"),
    lua   : re("uneReGeX-lua.*")
)

lang par défaut étant python donc re seul équivaut en interne à implement(python, re("..."))


> ---------------------------- <

le pérécdoe construit prend en charge certains valideurs

    --> str pour string, int...

    --> sin on pris en compte, cela apparaitra clairemnt en commentaire de début de code


> ---------------------------- <

un bloc initial spécial OBLIGATOIRE pour les noms des valideurs afin de répérer des erreurs de saisie;, ou les noms des variables sont juste là pour la sign impércise$

les valideuyrs recoivent un arg et en renvoie un autre, charge au codeur d'utiliser des struct avancés pour multiplier les infos

desc will be dded in autogrenerated code : in Python; we defined a class with metho to be im^lemnted, on surcalsse pour autoriser des me plsu tard; garder cela pour tout les langages pris en compte dans la mesuer du possible


vs.yaml a ses headers dans vs.hd.yaml : plus simple à gérer et poermet de la verbosté dans les desc

myfile.vs.hd.yaml

  myvalid_1: >
    Validated data: ...

    Returned value: ...

  myvalid_2: \path.other.psec.reused\


> ---------------------------- <

XXX


> ---------------------------- <

XXX
